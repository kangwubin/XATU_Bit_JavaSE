package cn.datatype;
//1. int 表示变量的类型是一个整型
//2. 变量名是变量的标识. 后续都是通过这个名字来使用变量
//3. Java 中 = 表示赋值(和数学不一样), 意思是给变量设置一个初始值.
//4. 初始化操作是可选的, 但是建议创建变量的时候都显式初始化.
//5. 最后不要忘记分号, 否则会编译失败.
//6. 表示注释. 注释作为代码的解释说明部分, 不参与编译运行.
//在 Java 中, 一个 int 变量占 4 个字节. 和操作系统没有直接关系.
//计算机使用二进制表示数据. 我们认为 8 个二进制位(bit) 为一个字节(Byte).
//4 个字节表示的数据范围是 -2^31 -> 2^31-1 , 也就大概是 -21亿 ~ +21亿
//Java 中 long 类型占 8 个字节. 表示的数据范围 -2^63 -> 2^63-1
public class Test1_DataType {
    public static void main(String[] args){
        //java中int/int的值仍然是int（会直接舍弃小数部分）
        int a=1;
        int b=2;
        int c=a/b;
        System.out.println(c);  //结果为0
        //如果想要得到0.5；得用double
        double d=1;
        double e=2;
        double f=d/e;
        System.out.println(f);  //结果为0.5
        //1. Java中使用单引号 + 单个字母的形式表示字符字面值.
        //2. 计算机中的字符本质上是一个整数. 在C语言中使用ASCII表示字符, 而Java中使用Unicode表示字符.
        // 因此一个字符占用两个字节, 表示的字符种类更多, 包括中文.
        char ch='呵';
        System.out.println(ch);
        //1. 字节类型表示的也是整数. 只占一个字节, 表示范围较小 ( -128 -> +127 )
        //2. 字节类型和字符类型互不相干
        byte value=127;
        System.out.println(value);
        //1. short占用2个字节, 表示的数据范围是 -32768 -> +32767
        //2. 这个表示范围比较小, 一般不推荐使用.
        short sValue=2568;
        System.out.println(sValue);
        //1. boolean 类型的变量只有两种取值, true 表示真, false 表示假.
        //2. Java 的 boolean 类型和 int 不能相互转换, 不存在 1 表示 true, 0 表示 false 这样的用法.
        //3. boolean 类型有些 JVM 的实现是占 1 个字节, 有些是占 1 个比特位, 这个没有明确规定
        boolean bValue=true;
        //System.out.println(bValue+1);   //不能进行转换计算
        //1. Java 使用 双引号 + 若干字符 的方式表示字符串字面值.
        //2. 和上面的类型不同, String 不是基本类型, 而是引用类型(后面重点解释).
        //3. 字符串中的一些特定的不太方便直接表示的字符需要进行转义.
        String name="康武斌";
        System.out.println(name);
        //long 表示的范围更大, 可以将 int 赋值给 long, 但是不能将 long 赋值给 int.
        //double 表示的范围更大, 可以将 int 赋值给 double, 但是不能将 double 赋值给 int.
        //结论: 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型, 反之则不行.
        int a1=10;
        long a2=20;
        //a1=a2;编译出错
        a2=a1;
        System.out.println("a1="+a1+","+"a2="+a2);
        //结论: int 和 boolean 是毫不相干的两种类型, 不能相互赋值.
        //结论: 使用字面值常量赋值的时候, Java 会自动进行一些检查校验, 判定赋值是否合理
        byte a3=100;
        //byte a4=256; // 编译报错, 提示 从int转换到byte可能会有损失
        //结论: 使用 (类型) 的方式可以将 double 类型强制转成 int. 但是
        //1. 强制类型转换可能会导致精度丢失. 如刚才的例子中, 赋值之后, 10.5 就变成 10 了, 小数点后面的部分被忽略.
        //2. 强制类型转换不是一定能成功, 互不相干的类型之间无法强转.
        int a4 = 0;
        double a5 = 10.5;
        a4 = (int)a5;
        int a6 = 10;
        boolean a7 = false;
//        a7 = (boolean)a6;   不兼容的类型
        //1. 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型.
        //2. 如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是可能精度丢失.
        //3. 将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查.

        //int 和long 的混合运算：
        //结论: 当 int 和 long 混合运算的时候, int 会提升成 long, 得到的结果仍然是 long 类型,
        // 需要使用 long 类型的变量来接收结果. 如果非要用 int 来接收结果, 就需要使用强制类型转换.

        //byte 和byte的运算：
        //结论: byte 和 byte 都是相同类型, 但是出现编译报错. 原因是, 虽然 a 和 b 都是 byte,
        // 但是计算 a + b 会先将 a 和 b 都提升成 int, 再进行计算, 得到的结果也是 int, 这是赋给 c, 就会出现上述错误.
        //由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据.
        // 为了硬件上实现方便, 诸如 byte 和 short 这种低于4个字节的类型, 会先提升成 int, 再参与计算.
        byte a8 = 10;
        byte a9 = 20;
        //byte a10= a8 + a9;
        //类型提升小结:
        //1. 不同类型的数据混合运算, 范围小的会提升成范围大的.
        //2. 对于 short, byte 这种比 4 个字节小的类型, 会先提升成 4 个字节的 int , 再运算.
    }
}
